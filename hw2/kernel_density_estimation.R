### kernel_density_estimation.R
###
### Defines functions for creating probability density function estimations
### using the kernel density estimation method. This includes a bunch of
### various kernel functions including the parzen window function and 
### a variety of gaussian kernel functions.

# For get_gaussian_pdf
source('common.R')

# Gets a gaussian kernel function for use in parzen window pdf estimator. It
# assumes you want the variance to be 1.
get_unit_variance_gaussian_kernel_fn <- function(data) {
	k     <- ncol(data)
	mu    <- matrix(0, ncol = k, nrow = 1)
	sigma <- diag(k)

	get_gaussian_pdf(mu, sigma)
}

# Gets a gaussian kernel function where the covariance matrix is I*sigma^2,
# where sigma^2 is the mean of the variance across all dimensions of the
# data
get_mean_variance_gaussian_kernel_fn <- function(data) {
	k      <- ncol(data)
	mu     <- matrix(0, ncol = k, nrow = 1)
	sigma  <- diag(k) * mean( sd(data) )

	get_gaussian_pdf(mu, sigma)
}

# Gets a gaussian kernel function where the covariance matrix is a 
# diagonal matrix. Sigma_ii = variance for dimension i in the data.
get_diagonal_variance_gaussian_kernel_fn <- function(data) {
	k      <- ncol(data)
	mu     <- matrix(0, ncol = k, nrow = 1)
	sigma  <- diag( sd(data)^2 )

	get_gaussian_pdf(mu, sigma)
}

# Get a gaussian kernel function where Sigma = cov(data). If cov(data) is
# singular, this won't work. A possible workaround might be to add some
# very small random values to data.
get_gaussian_kernel_fn <- function(data) {
	k      <- ncol(data)
	mu     <- matrix(0, ncol = k, nrow = 1)
	sigma  <- cov(data)

	get_gaussian_pdf(mu, sigma)
}

# The naive kernel function that returns 1 if the point is in a hypercube
# with unit length centered at the orgin, and 0 otherwise.
get_delta_kernel_fn <- function(data) {
	function(X) {
		if (length(X[abs(X) <= (1/2)]) == length(X)) {
			return(1)
		}
		else {
			return(0)
		}
	}
}

# Gets a PDF estimator using the kernel window method. This is a generic 
# method that requires you to specify the kernel function. The third argument,
# window_fn_builder, should be a function that takes the training set as a
# parameter and returns a kernel function.
#
# This uses h^k as the volume of the region generated by the kernel function.
# Clearly, this is not always the case. So one should be careful to not 
# treat values returned by this less as probabilities and more like scores.
get_kernel_density_fn <- function(data, h, window_fn_builder) {
	# Number of dimensions in the data
	k <- ncol(data)
	# Number of vectors in the sample
	n <- nrow(data)
	# Volume of the k-dimensional hypercube.
	V <- (h^k)
	# Get the window function, which can be constructed from the argument
	# window_fn_builder
	phi <- window_fn_builder(data)

	function(X) {
		# Compute the diff for each vector with a matrix operation. It ends up
		# being faster this way.
		sum  <- sum( apply(data, 1, function(xi) { phi((X - xi) / h) }) )

		# Divide by the volme after the fact. This prevents buffer underflow in
		# some cases.
		sum / (n * V)
	}
}
